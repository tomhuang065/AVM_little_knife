{"ast":null,"code":"'use strict';\n\nvar refractorScheme = require('./scheme.js');\n\nmodule.exports = racket;\nracket.displayName = 'racket';\nracket.aliases = ['rkt'];\n\nfunction racket(Prism) {\n  Prism.register(refractorScheme);\n  Prism.languages.racket = Prism.languages.extend('scheme', {\n    'lambda-parameter': {\n      // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n      // this will just prevent false positives of the `function` pattern\n      pattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n      lookbehind: true\n    }\n  }); // Add brackets to racket\n  // The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n  // and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n  // have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n  // and \")\".\n  // To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n  // matches from left to right and already matched text cannot be matched again. We use this to first capture all\n  // escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n  // all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n  // set whole.\n  // With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n  // with /[([]/ and replace all \"(\" inside character sets.\n  // Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\n\n  Prism.languages.DFS(Prism.languages.racket, function (key, value) {\n    if (Prism.util.type(value) === 'RegExp') {\n      var source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n        if (g1) {\n          if (g1 === '(') {\n            // replace all '(' characters outside character sets\n            return '[([]';\n          }\n\n          if (g1 === ')') {\n            // replace all ')' characters outside character sets\n            return '[)\\\\]]';\n          }\n        }\n\n        if (g2) {\n          var prefix = m[1] === '^' ? '[^' : '[';\n          return prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n            if (m === '(' || g1 === '(') {\n              // replace all '(' characters inside character sets\n              return '([';\n            }\n\n            if (m === ')' || g1 === ')') {\n              // replace all ')' characters inside character sets\n              return ')\\\\]';\n            }\n\n            return m;\n          }) + ']';\n        }\n\n        return m;\n      });\n      this[key] = RegExp(source, value.flags);\n    }\n  });\n  Prism.languages.insertBefore('racket', 'string', {\n    lang: {\n      pattern: /^#lang.+/m,\n      greedy: true,\n      alias: 'keyword'\n    }\n  });\n  Prism.languages.rkt = Prism.languages.racket;\n}","map":{"version":3,"sources":["/home/tomhuang/Developpement web/final_project/wp_final_project/MyApp/node_modules/refractor/lang/racket.js"],"names":["refractorScheme","require","module","exports","racket","displayName","aliases","Prism","register","languages","extend","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","prefix","RegExp","flags","insertBefore","lang","greedy","alias","rkt"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAGC,OAAO,CAAC,aAAD,CAA7B;;AACAC,MAAM,CAACC,OAAP,GAAiBC,MAAjB;AACAA,MAAM,CAACC,WAAP,GAAqB,QAArB;AACAD,MAAM,CAACE,OAAP,GAAiB,CAAC,KAAD,CAAjB;;AACA,SAASF,MAAT,CAAgBG,KAAhB,EAAuB;AACrBA,EAAAA,KAAK,CAACC,QAAN,CAAeR,eAAf;AACAO,EAAAA,KAAK,CAACE,SAAN,CAAgBL,MAAhB,GAAyBG,KAAK,CAACE,SAAN,CAAgBC,MAAhB,CAAuB,QAAvB,EAAiC;AACxD,wBAAoB;AAClB;AACA;AACAC,MAAAA,OAAO,EAAE,0BAHS;AAIlBC,MAAAA,UAAU,EAAE;AAJM;AADoC,GAAjC,CAAzB,CAFqB,CASlB;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAL,EAAAA,KAAK,CAACE,SAAN,CAAgBI,GAAhB,CAAoBN,KAAK,CAACE,SAAN,CAAgBL,MAApC,EAA4C,UAAUU,GAAV,EAAeC,KAAf,EAAsB;AAChE,QAAIR,KAAK,CAACS,IAAN,CAAWC,IAAX,CAAgBF,KAAhB,MAA2B,QAA/B,EAAyC;AACvC,UAAIG,MAAM,GAAGH,KAAK,CAACG,MAAN,CAAaC,OAAb,CACX,kCADW,EAEX,UAAUC,CAAV,EAAaC,EAAb,EAAiBC,EAAjB,EAAqB;AACnB,YAAID,EAAJ,EAAQ;AACN,cAAIA,EAAE,KAAK,GAAX,EAAgB;AACd;AACA,mBAAO,MAAP;AACD;;AACD,cAAIA,EAAE,KAAK,GAAX,EAAgB;AACd;AACA,mBAAO,QAAP;AACD;AACF;;AACD,YAAIC,EAAJ,EAAQ;AACN,cAAIC,MAAM,GAAGH,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,GAAe,IAAf,GAAsB,GAAnC;AACA,iBACEG,MAAM,GACND,EAAE,CAACH,OAAH,CAAW,aAAX,EAA0B,UAAUC,CAAV,EAAaC,EAAb,EAAiB;AACzC,gBAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC3B;AACA,qBAAO,IAAP;AACD;;AACD,gBAAID,CAAC,KAAK,GAAN,IAAaC,EAAE,KAAK,GAAxB,EAA6B;AAC3B;AACA,qBAAO,MAAP;AACD;;AACD,mBAAOD,CAAP;AACD,WAVD,CADA,GAYA,GAbF;AAeD;;AACD,eAAOA,CAAP;AACD,OAhCU,CAAb;AAkCA,WAAKN,GAAL,IAAYU,MAAM,CAACN,MAAD,EAASH,KAAK,CAACU,KAAf,CAAlB;AACD;AACF,GAtCD;AAuCAlB,EAAAA,KAAK,CAACE,SAAN,CAAgBiB,YAAhB,CAA6B,QAA7B,EAAuC,QAAvC,EAAiD;AAC/CC,IAAAA,IAAI,EAAE;AACJhB,MAAAA,OAAO,EAAE,WADL;AAEJiB,MAAAA,MAAM,EAAE,IAFJ;AAGJC,MAAAA,KAAK,EAAE;AAHH;AADyC,GAAjD;AAOAtB,EAAAA,KAAK,CAACE,SAAN,CAAgBqB,GAAhB,GAAsBvB,KAAK,CAACE,SAAN,CAAgBL,MAAtC;AACD","sourcesContent":["'use strict'\nvar refractorScheme = require('./scheme.js')\nmodule.exports = racket\nracket.displayName = 'racket'\nracket.aliases = ['rkt']\nfunction racket(Prism) {\n  Prism.register(refractorScheme)\n  Prism.languages.racket = Prism.languages.extend('scheme', {\n    'lambda-parameter': {\n      // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n      // this will just prevent false positives of the `function` pattern\n      pattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n      lookbehind: true\n    }\n  }) // Add brackets to racket\n  // The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n  // and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n  // have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n  // and \")\".\n  // To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n  // matches from left to right and already matched text cannot be matched again. We use this to first capture all\n  // escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n  // all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n  // set whole.\n  // With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n  // with /[([]/ and replace all \"(\" inside character sets.\n  // Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\n  Prism.languages.DFS(Prism.languages.racket, function (key, value) {\n    if (Prism.util.type(value) === 'RegExp') {\n      var source = value.source.replace(\n        /\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g,\n        function (m, g1, g2) {\n          if (g1) {\n            if (g1 === '(') {\n              // replace all '(' characters outside character sets\n              return '[([]'\n            }\n            if (g1 === ')') {\n              // replace all ')' characters outside character sets\n              return '[)\\\\]]'\n            }\n          }\n          if (g2) {\n            var prefix = m[1] === '^' ? '[^' : '['\n            return (\n              prefix +\n              g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n                if (m === '(' || g1 === '(') {\n                  // replace all '(' characters inside character sets\n                  return '(['\n                }\n                if (m === ')' || g1 === ')') {\n                  // replace all ')' characters inside character sets\n                  return ')\\\\]'\n                }\n                return m\n              }) +\n              ']'\n            )\n          }\n          return m\n        }\n      )\n      this[key] = RegExp(source, value.flags)\n    }\n  })\n  Prism.languages.insertBefore('racket', 'string', {\n    lang: {\n      pattern: /^#lang.+/m,\n      greedy: true,\n      alias: 'keyword'\n    }\n  })\n  Prism.languages.rkt = Prism.languages.racket\n}\n"]},"metadata":{},"sourceType":"script"}