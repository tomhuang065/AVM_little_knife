{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\n\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\n\n\nfunction concat(...args) {\n  const joined = args.map(x => source(x)).join(\"\");\n  return joined;\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\n\n\nfunction either(...args) {\n  const joined = '(' + args.map(x => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(/\\b/, keyword, /\\w$/.test(keyword) ? /\\b/ : /\\B/); // Keywords that require a leading dot.\n\n\nconst dotKeywords = ['Protocol', // contextual\n'Type' // contextual\n].map(keywordWrapper); // Keywords that may have a leading dot.\n\nconst optionalDotKeywords = ['init', 'self'].map(keywordWrapper); // should register as keyword, not type\n\nconst keywordTypes = ['Any', 'Self']; // Regular keywords and literals.\n\nconst keywords = [// strings below will be fed into the regular `keywords` engine while regex\n// will result in additional modes being created to scan for those keywords to\n// avoid conflicts with other rules\n'associatedtype', /as\\?/, // operator\n/as!/, // operator\n'as', // operator\n'break', 'case', 'catch', 'class', 'continue', 'convenience', // contextual\n'default', 'defer', 'deinit', 'didSet', // contextual\n'do', 'dynamic', // contextual\n'else', 'enum', 'extension', 'fallthrough', 'fileprivate(set)', 'fileprivate', 'final', // contextual\n'for', 'func', 'get', // contextual\n'guard', 'if', 'import', 'indirect', // contextual\n'infix', // contextual\n/init\\?/, /init!/, 'inout', 'internal(set)', 'internal', 'in', 'is', // operator\n'lazy', // contextual\n'let', 'mutating', // contextual\n'nonmutating', // contextual\n'open(set)', // contextual\n'open', // contextual\n'operator', 'optional', // contextual\n'override', // contextual\n'postfix', // contextual\n'precedencegroup', 'prefix', // contextual\n'private(set)', 'private', 'protocol', 'public(set)', 'public', 'repeat', 'required', // contextual\n'rethrows', 'return', 'set', // contextual\n'some', // contextual\n'static', 'struct', 'subscript', 'super', 'switch', 'throws', 'throw', /try\\?/, // operator\n/try!/, // operator\n'try', // operator\n'typealias', 'unowned(safe)', // contextual\n'unowned(unsafe)', // contextual\n'unowned', // contextual\n'var', 'weak', // contextual\n'where', 'while', 'willSet' // contextual\n]; // NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n// TODO: Create a PRECEDENCE_GROUP mode to match the remaining contextual keywords:\n// assignment associativity higherThan left lowerThan none right\n// These aren't included in the list because they result in mostly false positives.\n// Literals.\n\nconst literals = ['false', 'nil', 'true']; // Keywords that start with a number sign (#).\n// #available is handled separately.\n\nconst numberSignKeywords = ['#colorLiteral', '#column', '#dsohandle', '#else', '#elseif', '#endif', '#error', '#file', '#fileID', '#fileLiteral', '#filePath', '#function', '#if', '#imageLiteral', '#keyPath', '#line', '#selector', '#sourceLocation', '#warn_unqualified_access', '#warning']; // Global functions in the Standard Library.\n\nconst builtIns = ['abs', 'all', 'any', 'assert', 'assertionFailure', 'debugPrint', 'dump', 'fatalError', 'getVaList', 'isKnownUniquelyReferenced', 'max', 'min', 'numericCast', 'pointwiseMax', 'pointwiseMin', 'precondition', 'preconditionFailure', 'print', 'readLine', 'repeatElement', 'sequence', 'stride', 'swap', 'swift_unboxFromSwiftValueWithType', 'transcode', 'type', 'unsafeBitCast', 'unsafeDowncast', 'withExtendedLifetime', 'withUnsafeMutablePointer', 'withUnsafePointer', 'withVaList', 'withoutActuallyEscaping', 'zip']; // Valid first characters for operators.\n\nconst operatorHead = either(/[/=\\-+!*%<>&|^~?]/, /[\\u00A1-\\u00A7]/, /[\\u00A9\\u00AB]/, /[\\u00AC\\u00AE]/, /[\\u00B0\\u00B1]/, /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/, /[\\u2016-\\u2017]/, /[\\u2020-\\u2027]/, /[\\u2030-\\u203E]/, /[\\u2041-\\u2053]/, /[\\u2055-\\u205E]/, /[\\u2190-\\u23FF]/, /[\\u2500-\\u2775]/, /[\\u2794-\\u2BFF]/, /[\\u2E00-\\u2E7F]/, /[\\u3001-\\u3003]/, /[\\u3008-\\u3020]/, /[\\u3030]/); // Valid characters for operators.\n\nconst operatorCharacter = either(operatorHead, /[\\u0300-\\u036F]/, /[\\u1DC0-\\u1DFF]/, /[\\u20D0-\\u20FF]/, /[\\uFE00-\\uFE0F]/, /[\\uFE20-\\uFE2F]/ // TODO: The following characters are also allowed, but the regex isn't supported yet.\n// /[\\u{E0100}-\\u{E01EF}]/u\n); // Valid operator.\n\nconst operator = concat(operatorHead, operatorCharacter, '*'); // Valid first characters for identifiers.\n\nconst identifierHead = either(/[a-zA-Z_]/, /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/, /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/, /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/, /[\\u1E00-\\u1FFF]/, /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/, /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/, /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/, /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/, /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/, /[\\uFE47-\\uFFFD]/ // The following characters are also allowed, but the regexes aren't supported yet.\n// /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n// /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n// /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n// /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n); // Valid characters for identifiers.\n\nconst identifierCharacter = either(identifierHead, /\\d/, /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/); // Valid identifier.\n\nconst identifier = concat(identifierHead, identifierCharacter, '*'); // Valid type identifier.\n\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*'); // Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\n\nconst keywordAttributes = ['autoclosure', concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/), 'discardableResult', 'dynamicCallable', 'dynamicMemberLookup', 'escaping', 'frozen', 'GKInspectable', 'IBAction', 'IBDesignable', 'IBInspectable', 'IBOutlet', 'IBSegueAction', 'inlinable', 'main', 'nonobjc', 'NSApplicationMain', 'NSCopying', 'NSManaged', concat(/objc\\(/, identifier, /\\)/), 'objc', 'objcMembers', 'propertyWrapper', 'requires_stored_property_inits', 'testable', 'UIApplicationMain', 'unknown', 'usableFromInline']; // Contextual keywords used in @available and #available.\n\nconst availabilityKeywords = ['iOS', 'iOSApplicationExtension', 'macOS', 'macOSApplicationExtension', 'macCatalyst', 'macCatalystApplicationExtension', 'watchOS', 'watchOSApplicationExtension', 'tvOS', 'tvOSApplicationExtension', 'swift'];\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n/** @type LanguageFn */\n\nfunction swift(hljs) {\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT('/\\\\*', '\\\\*/', {\n    contains: ['self']\n  }); // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n\n  const DOT_KEYWORD = {\n    className: 'keyword',\n    begin: concat(/\\./, lookahead(either(...dotKeywords, ...optionalDotKeywords))),\n    end: either(...dotKeywords, ...optionalDotKeywords),\n    excludeBegin: true\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    begin: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords.filter(kw => typeof kw === 'string').concat([\"_|0\"]); // seems common, so 0 relevance\n\n  const REGEX_KEYWORDS = keywords.filter(kw => typeof kw !== 'string') // find regex\n  .concat(keywordTypes).map(keywordWrapper);\n  const KEYWORD = {\n    variants: [{\n      className: 'keyword',\n      begin: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n    }]\n  }; // find all the regular keywords\n\n  const KEYWORDS = {\n    $pattern: either(/\\b\\w+(\\(\\w+\\))?/, // kw or kw(arg)\n    /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS.concat(numberSignKeywords).join(\" \"),\n    literal: literals.join(\" \")\n  };\n  const KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD]; // https://github.com/apple/swift/tree/main/stdlib/public/core\n\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    begin: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    begin: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [BUILT_IN_GUARD, BUILT_IN]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    begin: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [{\n      begin: operator\n    }, {\n      // dot-operator: only operators that start with a dot are allowed to use dots as\n      // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n      // characters that may also include dots.\n      begin: `\\\\.(\\\\.|${operatorCharacter})+`\n    }]\n  };\n  const OPERATORS = [OPERATOR_GUARD, OPERATOR]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [// decimal floating-point-literal (subsumes decimal-literal)\n    {\n      begin: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\n    }, // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n    {\n      begin: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\n    }, // octal-literal\n    {\n      begin: /\\b0o([0-7]_*)+\\b/\n    }, // binary-literal\n    {\n      begin: /\\b0b([01]_*)+\\b/\n    }]\n  }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [{\n      begin: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n    }, {\n      begin: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n    }]\n  });\n\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    begin: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [ESCAPED_CHARACTER(rawDelimiter), ESCAPED_NEWLINE(rawDelimiter), INTERPOLATION(rawDelimiter)]\n  });\n\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)]\n  });\n\n  const STRING = {\n    className: 'string',\n    variants: [MULTILINE_STRING(), MULTILINE_STRING(\"#\"), MULTILINE_STRING(\"##\"), MULTILINE_STRING(\"###\"), SINGLE_LINE_STRING(), SINGLE_LINE_STRING(\"#\"), SINGLE_LINE_STRING(\"##\"), SINGLE_LINE_STRING(\"###\")]\n  }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n\n  const QUOTED_IDENTIFIER = {\n    begin: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    begin: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    begin: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [QUOTED_IDENTIFIER, IMPLICIT_PARAMETER, PROPERTY_WRAPPER_PROJECTION]; // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n\n  const AVAILABLE_ATTRIBUTE = {\n    begin: /(@|#)available\\(/,\n    end: /\\)/,\n    keywords: {\n      $pattern: /[@#]?\\w+/,\n      keyword: availabilityKeywords.concat([\"@available\", \"#available\"]).join(' ')\n    },\n    contains: [...OPERATORS, NUMBER, STRING]\n  };\n  const KEYWORD_ATTRIBUTE = {\n    className: 'keyword',\n    begin: concat(/@/, either(...keywordAttributes))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    className: 'meta',\n    begin: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [AVAILABLE_ATTRIBUTE, KEYWORD_ATTRIBUTE, USER_DEFINED_ATTRIBUTE]; // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n\n  const TYPE = {\n    begin: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [{\n      // Common Apple frameworks, for relevance boost\n      className: 'type',\n      begin: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n    }, {\n      // Type identifier\n      className: 'type',\n      begin: typeIdentifier,\n      relevance: 0\n    }, {\n      // Optional type\n      begin: /[?!]+/,\n      relevance: 0\n    }, {\n      // Variadic parameter\n      begin: /\\.\\.\\./,\n      relevance: 0\n    }, {\n      // Protocol composition\n      begin: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n      relevance: 0\n    }]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [...KEYWORD_MODES, ...ATTRIBUTES, OPERATOR_GUARD, TYPE]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS); // Add supported submodes to string interpolation.\n\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\"); // TODO: Interpolation can contain any expression, so there's room for improvement here.\n\n    interpolation.keywords = KEYWORDS;\n    const submodes = [...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS];\n    interpolation.contains = [...submodes, {\n      begin: /\\(/,\n      end: /\\)/,\n      contains: ['self', ...submodes]\n    }];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT, {\n      className: 'function',\n      beginKeywords: 'func',\n      end: /\\{/,\n      excludeEnd: true,\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        begin: /[A-Za-z$_][0-9A-Za-z$_]*/\n      }), {\n        begin: /</,\n        end: />/\n      }, {\n        className: 'params',\n        begin: /\\(/,\n        end: /\\)/,\n        endsParent: true,\n        keywords: KEYWORDS,\n        contains: ['self', ...KEYWORD_MODES, NUMBER, STRING, hljs.C_BLOCK_COMMENT_MODE, {\n          // relevance booster\n          begin: ':'\n        }],\n        illegal: /[\"']/\n      }],\n      illegal: /\\[|%/\n    }, {\n      className: 'class',\n      beginKeywords: 'struct protocol class extension enum',\n      end: '\\\\{',\n      excludeEnd: true,\n      keywords: KEYWORDS,\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\n      }), ...KEYWORD_MODES]\n    }, {\n      beginKeywords: 'import',\n      end: /$/,\n      contains: [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT],\n      relevance: 0\n    }, ...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS, ...ATTRIBUTES, TYPE]\n  };\n}\n\nmodule.exports = swift;","map":{"version":3,"sources":["/home/tomhuang/Developpement web/final_project/wp_final_project/MyApp/node_modules/highlight.js/lib/languages/swift.js"],"names":["source","re","lookahead","concat","args","joined","map","x","join","either","keywordWrapper","keyword","test","dotKeywords","optionalDotKeywords","keywordTypes","keywords","literals","numberSignKeywords","builtIns","operatorHead","operatorCharacter","operator","identifierHead","identifierCharacter","identifier","typeIdentifier","keywordAttributes","availabilityKeywords","swift","hljs","BLOCK_COMMENT","COMMENT","contains","DOT_KEYWORD","className","begin","end","excludeBegin","KEYWORD_GUARD","relevance","PLAIN_KEYWORDS","filter","kw","REGEX_KEYWORDS","KEYWORD","variants","KEYWORDS","$pattern","literal","KEYWORD_MODES","BUILT_IN_GUARD","BUILT_IN","BUILT_INS","OPERATOR_GUARD","OPERATOR","OPERATORS","decimalDigits","hexDigits","NUMBER","ESCAPED_CHARACTER","rawDelimiter","ESCAPED_NEWLINE","INTERPOLATION","label","MULTILINE_STRING","SINGLE_LINE_STRING","STRING","QUOTED_IDENTIFIER","IMPLICIT_PARAMETER","PROPERTY_WRAPPER_PROJECTION","IDENTIFIERS","AVAILABLE_ATTRIBUTE","KEYWORD_ATTRIBUTE","USER_DEFINED_ATTRIBUTE","ATTRIBUTES","TYPE","GENERIC_ARGUMENTS","push","variant","interpolation","find","mode","submodes","name","C_LINE_COMMENT_MODE","beginKeywords","excludeEnd","inherit","TITLE_MODE","endsParent","C_BLOCK_COMMENT_MODE","illegal","module","exports"],"mappings":"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","sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const joined = '(' + args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(\n  /\\b/,\n  keyword,\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\n);\n\n// Keywords that require a leading dot.\nconst dotKeywords = [\n  'Protocol', // contextual\n  'Type' // contextual\n].map(keywordWrapper);\n\n// Keywords that may have a leading dot.\nconst optionalDotKeywords = [\n  'init',\n  'self'\n].map(keywordWrapper);\n\n// should register as keyword, not type\nconst keywordTypes = [\n  'Any',\n  'Self'\n];\n\n// Regular keywords and literals.\nconst keywords = [\n  // strings below will be fed into the regular `keywords` engine while regex\n  // will result in additional modes being created to scan for those keywords to\n  // avoid conflicts with other rules\n  'associatedtype',\n  /as\\?/, // operator\n  /as!/, // operator\n  'as', // operator\n  'break',\n  'case',\n  'catch',\n  'class',\n  'continue',\n  'convenience', // contextual\n  'default',\n  'defer',\n  'deinit',\n  'didSet', // contextual\n  'do',\n  'dynamic', // contextual\n  'else',\n  'enum',\n  'extension',\n  'fallthrough',\n  'fileprivate(set)',\n  'fileprivate',\n  'final', // contextual\n  'for',\n  'func',\n  'get', // contextual\n  'guard',\n  'if',\n  'import',\n  'indirect', // contextual\n  'infix', // contextual\n  /init\\?/,\n  /init!/,\n  'inout',\n  'internal(set)',\n  'internal',\n  'in',\n  'is', // operator\n  'lazy', // contextual\n  'let',\n  'mutating', // contextual\n  'nonmutating', // contextual\n  'open(set)', // contextual\n  'open', // contextual\n  'operator',\n  'optional', // contextual\n  'override', // contextual\n  'postfix', // contextual\n  'precedencegroup',\n  'prefix', // contextual\n  'private(set)',\n  'private',\n  'protocol',\n  'public(set)',\n  'public',\n  'repeat',\n  'required', // contextual\n  'rethrows',\n  'return',\n  'set', // contextual\n  'some', // contextual\n  'static',\n  'struct',\n  'subscript',\n  'super',\n  'switch',\n  'throws',\n  'throw',\n  /try\\?/, // operator\n  /try!/, // operator\n  'try', // operator\n  'typealias',\n  'unowned(safe)', // contextual\n  'unowned(unsafe)', // contextual\n  'unowned', // contextual\n  'var',\n  'weak', // contextual\n  'where',\n  'while',\n  'willSet' // contextual\n];\n\n// NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n\n// TODO: Create a PRECEDENCE_GROUP mode to match the remaining contextual keywords:\n// assignment associativity higherThan left lowerThan none right\n// These aren't included in the list because they result in mostly false positives.\n\n// Literals.\nconst literals = [\n  'false',\n  'nil',\n  'true'\n];\n\n// Keywords that start with a number sign (#).\n// #available is handled separately.\nconst numberSignKeywords = [\n  '#colorLiteral',\n  '#column',\n  '#dsohandle',\n  '#else',\n  '#elseif',\n  '#endif',\n  '#error',\n  '#file',\n  '#fileID',\n  '#fileLiteral',\n  '#filePath',\n  '#function',\n  '#if',\n  '#imageLiteral',\n  '#keyPath',\n  '#line',\n  '#selector',\n  '#sourceLocation',\n  '#warn_unqualified_access',\n  '#warning'\n];\n\n// Global functions in the Standard Library.\nconst builtIns = [\n  'abs',\n  'all',\n  'any',\n  'assert',\n  'assertionFailure',\n  'debugPrint',\n  'dump',\n  'fatalError',\n  'getVaList',\n  'isKnownUniquelyReferenced',\n  'max',\n  'min',\n  'numericCast',\n  'pointwiseMax',\n  'pointwiseMin',\n  'precondition',\n  'preconditionFailure',\n  'print',\n  'readLine',\n  'repeatElement',\n  'sequence',\n  'stride',\n  'swap',\n  'swift_unboxFromSwiftValueWithType',\n  'transcode',\n  'type',\n  'unsafeBitCast',\n  'unsafeDowncast',\n  'withExtendedLifetime',\n  'withUnsafeMutablePointer',\n  'withUnsafePointer',\n  'withVaList',\n  'withoutActuallyEscaping',\n  'zip'\n];\n\n// Valid first characters for operators.\nconst operatorHead = either(\n  /[/=\\-+!*%<>&|^~?]/,\n  /[\\u00A1-\\u00A7]/,\n  /[\\u00A9\\u00AB]/,\n  /[\\u00AC\\u00AE]/,\n  /[\\u00B0\\u00B1]/,\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\n  /[\\u2016-\\u2017]/,\n  /[\\u2020-\\u2027]/,\n  /[\\u2030-\\u203E]/,\n  /[\\u2041-\\u2053]/,\n  /[\\u2055-\\u205E]/,\n  /[\\u2190-\\u23FF]/,\n  /[\\u2500-\\u2775]/,\n  /[\\u2794-\\u2BFF]/,\n  /[\\u2E00-\\u2E7F]/,\n  /[\\u3001-\\u3003]/,\n  /[\\u3008-\\u3020]/,\n  /[\\u3030]/\n);\n\n// Valid characters for operators.\nconst operatorCharacter = either(\n  operatorHead,\n  /[\\u0300-\\u036F]/,\n  /[\\u1DC0-\\u1DFF]/,\n  /[\\u20D0-\\u20FF]/,\n  /[\\uFE00-\\uFE0F]/,\n  /[\\uFE20-\\uFE2F]/\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\n  // /[\\u{E0100}-\\u{E01EF}]/u\n);\n\n// Valid operator.\nconst operator = concat(operatorHead, operatorCharacter, '*');\n\n// Valid first characters for identifiers.\nconst identifierHead = either(\n  /[a-zA-Z_]/,\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\n  /[\\u1E00-\\u1FFF]/,\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\n  /[\\uFE47-\\uFFFD]/\n  // The following characters are also allowed, but the regexes aren't supported yet.\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n);\n\n// Valid characters for identifiers.\nconst identifierCharacter = either(\n  identifierHead,\n  /\\d/,\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\n);\n\n// Valid identifier.\nconst identifier = concat(identifierHead, identifierCharacter, '*');\n\n// Valid type identifier.\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\n\n// Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\nconst keywordAttributes = [\n  'autoclosure',\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\n  'discardableResult',\n  'dynamicCallable',\n  'dynamicMemberLookup',\n  'escaping',\n  'frozen',\n  'GKInspectable',\n  'IBAction',\n  'IBDesignable',\n  'IBInspectable',\n  'IBOutlet',\n  'IBSegueAction',\n  'inlinable',\n  'main',\n  'nonobjc',\n  'NSApplicationMain',\n  'NSCopying',\n  'NSManaged',\n  concat(/objc\\(/, identifier, /\\)/),\n  'objc',\n  'objcMembers',\n  'propertyWrapper',\n  'requires_stored_property_inits',\n  'testable',\n  'UIApplicationMain',\n  'unknown',\n  'usableFromInline'\n];\n\n// Contextual keywords used in @available and #available.\nconst availabilityKeywords = [\n  'iOS',\n  'iOSApplicationExtension',\n  'macOS',\n  'macOSApplicationExtension',\n  'macCatalyst',\n  'macCatalystApplicationExtension',\n  'watchOS',\n  'watchOSApplicationExtension',\n  'tvOS',\n  'tvOSApplicationExtension',\n  'swift'\n];\n\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n/** @type LanguageFn */\nfunction swift(hljs) {\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT(\n    '/\\\\*',\n    '\\\\*/',\n    {\n      contains: [ 'self' ]\n    }\n  );\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n  const DOT_KEYWORD = {\n    className: 'keyword',\n    begin: concat(/\\./, lookahead(either(...dotKeywords, ...optionalDotKeywords))),\n    end: either(...dotKeywords, ...optionalDotKeywords),\n    excludeBegin: true\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    begin: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords\n    .filter(kw => typeof kw === 'string')\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\n  const REGEX_KEYWORDS = keywords\n    .filter(kw => typeof kw !== 'string') // find regex\n    .concat(keywordTypes)\n    .map(keywordWrapper);\n  const KEYWORD = {\n    variants: [\n      {\n        className: 'keyword',\n        begin: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n      }\n    ]\n  };\n  // find all the regular keywords\n  const KEYWORDS = {\n    $pattern: either(\n      /\\b\\w+(\\(\\w+\\))?/, // kw or kw(arg)\n      /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS\n      .concat(numberSignKeywords)\n      .join(\" \"),\n    literal: literals.join(\" \")\n  };\n  const KEYWORD_MODES = [\n    DOT_KEYWORD,\n    KEYWORD_GUARD,\n    KEYWORD\n  ];\n\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    begin: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    begin: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [\n    BUILT_IN_GUARD,\n    BUILT_IN\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    begin: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [\n      {\n        begin: operator\n      },\n      {\n        // dot-operator: only operators that start with a dot are allowed to use dots as\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n        // characters that may also include dots.\n        begin: `\\\\.(\\\\.|${operatorCharacter})+`\n      }\n    ]\n  };\n  const OPERATORS = [\n    OPERATOR_GUARD,\n    OPERATOR\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [\n      // decimal floating-point-literal (subsumes decimal-literal)\n      {\n        begin: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n      {\n        begin: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // octal-literal\n      {\n        begin: /\\b0o([0-7]_*)+\\b/\n      },\n      // binary-literal\n      {\n        begin: /\\b0b([01]_*)+\\b/\n      }\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [\n      {\n        begin: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n      },\n      {\n        begin: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n      }\n    ]\n  });\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    begin: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      ESCAPED_NEWLINE(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const STRING = {\n    className: 'string',\n    variants: [\n      MULTILINE_STRING(),\n      MULTILINE_STRING(\"#\"),\n      MULTILINE_STRING(\"##\"),\n      MULTILINE_STRING(\"###\"),\n      SINGLE_LINE_STRING(),\n      SINGLE_LINE_STRING(\"#\"),\n      SINGLE_LINE_STRING(\"##\"),\n      SINGLE_LINE_STRING(\"###\")\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n  const QUOTED_IDENTIFIER = {\n    begin: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    begin: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    begin: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [\n    QUOTED_IDENTIFIER,\n    IMPLICIT_PARAMETER,\n    PROPERTY_WRAPPER_PROJECTION\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n  const AVAILABLE_ATTRIBUTE = {\n    begin: /(@|#)available\\(/,\n    end: /\\)/,\n    keywords: {\n      $pattern: /[@#]?\\w+/,\n      keyword: availabilityKeywords\n        .concat([\n          \"@available\",\n          \"#available\"\n        ])\n        .join(' ')\n    },\n    contains: [\n      ...OPERATORS,\n      NUMBER,\n      STRING\n    ]\n  };\n  const KEYWORD_ATTRIBUTE = {\n    className: 'keyword',\n    begin: concat(/@/, either(...keywordAttributes))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    className: 'meta',\n    begin: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [\n    AVAILABLE_ATTRIBUTE,\n    KEYWORD_ATTRIBUTE,\n    USER_DEFINED_ATTRIBUTE\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n  const TYPE = {\n    begin: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [\n      { // Common Apple frameworks, for relevance boost\n        className: 'type',\n        begin: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n      },\n      { // Type identifier\n        className: 'type',\n        begin: typeIdentifier,\n        relevance: 0\n      },\n      { // Optional type\n        begin: /[?!]+/,\n        relevance: 0\n      },\n      { // Variadic parameter\n        begin: /\\.\\.\\./,\n        relevance: 0\n      },\n      { // Protocol composition\n        begin: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n        relevance: 0\n      }\n    ]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [\n      ...KEYWORD_MODES,\n      ...ATTRIBUTES,\n      OPERATOR_GUARD,\n      TYPE\n    ]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS);\n\n  // Add supported submodes to string interpolation.\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\n    interpolation.keywords = KEYWORDS;\n    const submodes = [\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS\n    ];\n    interpolation.contains = [\n      ...submodes,\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [\n          'self',\n          ...submodes\n        ]\n      }\n    ];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [\n      hljs.C_LINE_COMMENT_MODE,\n      BLOCK_COMMENT,\n      {\n        className: 'function',\n        beginKeywords: 'func',\n        end: /\\{/,\n        excludeEnd: true,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: /[A-Za-z$_][0-9A-Za-z$_]*/\n          }),\n          {\n            begin: /</,\n            end: />/\n          },\n          {\n            className: 'params',\n            begin: /\\(/,\n            end: /\\)/,\n            endsParent: true,\n            keywords: KEYWORDS,\n            contains: [\n              'self',\n              ...KEYWORD_MODES,\n              NUMBER,\n              STRING,\n              hljs.C_BLOCK_COMMENT_MODE,\n              { // relevance booster\n                begin: ':'\n              }\n            ],\n            illegal: /[\"']/\n          }\n        ],\n        illegal: /\\[|%/\n      },\n      {\n        className: 'class',\n        beginKeywords: 'struct protocol class extension enum',\n        end: '\\\\{',\n        excludeEnd: true,\n        keywords: KEYWORDS,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\n          }),\n          ...KEYWORD_MODES\n        ]\n      },\n      {\n        beginKeywords: 'import',\n        end: /$/,\n        contains: [\n          hljs.C_LINE_COMMENT_MODE,\n          BLOCK_COMMENT\n        ],\n        relevance: 0\n      },\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE\n    ]\n  };\n}\n\nmodule.exports = swift;\n"]},"metadata":{},"sourceType":"script"}